{"version":3,"file":"index.cjs.production.min.js","sources":["../src/types/index.ts","../src/utils/findNearestBinarySearch.ts","../src/utils/isNumber.ts","../src/utils/now.ts","../src/utils/useLatest.ts","../src/utils/useIsoLayoutEffect.ts","../src/useVirtual.ts","../src/utils/useDebounce.ts","../src/utils/shouldUpdate.ts","../src/utils/useResizeEffect.ts"],"sourcesContent":["import { MutableRefObject, RefCallback } from \"react\";\n\n// Internal\nexport interface State {\n  items: Item[];\n  innerMargin?: number;\n  innerSize?: number;\n}\n\nexport interface Measure {\n  idx: number;\n  start: number;\n  end: number;\n  size: number;\n}\n\n// External\nexport type SsrItemCount = number | [number, number];\n\ntype UseIsScrolling = boolean | ((speed: number) => boolean);\n\nexport type ItemSize = number | ((index: number, width: number) => number);\n\ntype ScrollDuration = number | ((distance: number) => number);\n\ninterface ScrollEasingFunction {\n  (time: number): number;\n}\n\ninterface IsItemLoaded {\n  (index: number): boolean;\n}\n\ninterface LoadMore {\n  (event: {\n    startIndex: number;\n    stopIndex: number;\n    loadIndex: number;\n    readonly scrollOffset: number;\n    readonly userScroll: boolean;\n  }): void;\n}\n\ninterface OnScroll {\n  (event: {\n    overscanStartIndex: number;\n    overscanStopIndex: number;\n    visibleStartIndex: number;\n    visibleStopIndex: number;\n    readonly scrollOffset: number;\n    readonly scrollForward: boolean;\n    readonly userScroll: boolean;\n  }): void;\n}\n\nexport interface OnResizeEvent {\n  width: number;\n  height: number;\n}\n\nexport interface OnResize {\n  (event: OnResizeEvent): void;\n}\n\nexport interface Item {\n  readonly index: number;\n  readonly start: number;\n  readonly size: number;\n  readonly width: number;\n  readonly isScrolling?: true;\n  readonly isSticky?: true;\n  measureRef: RefCallback<HTMLElement>;\n}\n\nexport interface ScrollToOptions {\n  offset: number;\n  smooth?: boolean;\n}\n\nexport interface ScrollTo {\n  (value: number | ScrollToOptions, callback?: () => void): void;\n}\n\nexport enum Align {\n  auto = \"auto\",\n  start = \"start\",\n  center = \"center\",\n  end = \"end\",\n}\n\nexport interface ScrollToItemOptions {\n  index: number;\n  align?: Align;\n  smooth?: boolean;\n}\n\nexport interface ScrollToItem {\n  (index: number | ScrollToItemOptions, callback?: () => void): void;\n}\n\nexport interface StartItem {\n  (index: number, callback?: () => void): void;\n}\n\nexport interface Options {\n  itemCount: number;\n  ssrItemCount?: SsrItemCount;\n  itemSize?: ItemSize;\n  horizontal?: boolean;\n  resetScroll?: boolean;\n  overscanCount?: number;\n  useIsScrolling?: UseIsScrolling;\n  stickyIndices?: number[];\n  scrollDuration?: ScrollDuration;\n  scrollEasingFunction?: ScrollEasingFunction;\n  loadMoreCount?: number;\n  isItemLoaded?: IsItemLoaded;\n  loadMore?: LoadMore;\n  onScroll?: OnScroll;\n  onResize?: OnResize;\n}\n\nexport interface Return<O = any, I = any> {\n  outerRef: MutableRefObject<O | null>;\n  innerRef: MutableRefObject<I | null>;\n  items: Item[];\n  scrollTo: ScrollTo;\n  scrollToItem: ScrollToItem;\n  startItem: StartItem;\n}\n","export default (\n  low: number,\n  high: number,\n  input: number,\n  getVal: (idx: number) => number\n): number => {\n  while (low <= high) {\n    const mid = ((low + high) / 2) | 0;\n    const val = getVal(mid);\n\n    if (input < val) {\n      high = mid - 1;\n    } else if (input > val) {\n      low = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return low > 0 ? low - 1 : 0;\n};\n","export default (val: unknown): val is number =>\n  typeof val === \"number\" && !Number.isNaN(val);\n","export default (): number =>\n  // eslint-disable-next-line compat/compat\n  \"performance\" in window ? performance.now() : Date.now();\n","import { MutableRefObject, useRef } from \"react\";\n\nexport default <T>(val: T): MutableRefObject<T> => {\n  const ref = useRef(val);\n  ref.current = val;\n  return ref;\n};\n","import { useEffect, useLayoutEffect } from \"react\";\n\nexport default typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { useCallback, useRef, useState } from \"react\";\n\nimport {\n  Align,\n  Item,\n  ItemSize,\n  Measure,\n  Options,\n  Return,\n  ScrollTo,\n  ScrollToOptions,\n  ScrollToItem,\n  ScrollToItemOptions,\n  SsrItemCount,\n  StartItem,\n  State,\n} from \"./types\";\nimport {\n  findNearestBinarySearch,\n  isNumber,\n  now,\n  shouldUpdate,\n  useDebounce,\n  useIsoLayoutEffect,\n  useLatest,\n  useResizeEffect,\n} from \"./utils\";\n\nconst getInitState = (itemSize: ItemSize, ssrItemCount: SsrItemCount = 0) => {\n  const [idx, len] = isNumber(ssrItemCount)\n    ? [0, ssrItemCount - 1]\n    : ssrItemCount;\n  const items = [];\n\n  for (let i = idx; i <= len; i += 1)\n    items.push({\n      index: i,\n      start: 0,\n      width: 0,\n      size: isNumber(itemSize) ? itemSize : itemSize(i, 0),\n      measureRef: /* istanbul ignore next */ () => null,\n    });\n\n  return { items };\n};\n\nexport default <\n  O extends HTMLElement = HTMLElement,\n  I extends HTMLElement = O\n>({\n  itemCount,\n  ssrItemCount,\n  itemSize = 50,\n  horizontal,\n  resetScroll,\n  overscanCount = 1,\n  useIsScrolling,\n  stickyIndices,\n  // Default = 100ms <= distance * 0.75 <= 500ms\n  scrollDuration = (d) => Math.min(Math.max(d * 0.075, 100), 500),\n  // Default = easeInOutSine\n  scrollEasingFunction = (t) => -(Math.cos(Math.PI * t) - 1) / 2,\n  loadMoreCount = 15,\n  isItemLoaded,\n  loadMore,\n  onScroll,\n  onResize,\n}: Options): Return<O, I> => {\n  const [state, setState] = useState<State>(() =>\n    getInitState(itemSize, ssrItemCount)\n  );\n  const isMountedRef = useRef(false);\n  const isScrollingRef = useRef(true);\n  const isScrollToItemRef = useRef(false);\n  const hasDynamicSizeRef = useRef(false);\n  const rosRef = useRef<Map<Element, ResizeObserver>>(new Map());\n  const scrollOffsetRef = useRef(0);\n  const prevItemIdxRef = useRef(-1);\n  const prevVStopRef = useRef(-1);\n  const outerRef = useRef<O>(null);\n  const innerRef = useRef<I>(null);\n  const outerRectRef = useRef({ width: 0, height: 0 });\n  const msDataRef = useRef<Measure[]>([]);\n  const userScrollRef = useRef(true);\n  const scrollToRafRef = useRef<number>();\n  const stickyIndicesRef = useLatest(stickyIndices);\n  const durationRef = useLatest(scrollDuration);\n  const easingFnRef = useLatest(scrollEasingFunction);\n  const isItemLoadedRef = useLatest(isItemLoaded);\n  const loadMoreRef = useLatest(loadMore);\n  const itemSizeRef = useLatest(itemSize);\n  const useIsScrollingRef = useLatest(useIsScrolling);\n  const onScrollRef = useLatest(onScroll);\n  const onResizeRef = useLatest(onResize);\n  const sizeKey = !horizontal ? \"height\" : \"width\";\n  const marginKey = !horizontal ? \"marginTop\" : \"marginLeft\";\n  const scrollKey = !horizontal ? \"scrollTop\" : \"scrollLeft\";\n\n  const getItemSize = useCallback(\n    (idx: number) => {\n      const { current: size } = itemSizeRef;\n      return isNumber(size) ? size : size(idx, outerRectRef.current.width);\n    },\n    [itemSizeRef]\n  );\n\n  const getMeasure = useCallback((idx: number, size: number): Measure => {\n    const start = msDataRef.current[idx - 1]?.end ?? 0;\n    return { idx, start, end: start + size, size };\n  }, []);\n\n  const measureItems = useCallback(\n    (useCache = true) => {\n      msDataRef.current.length = itemCount;\n\n      for (let i = 0; i < itemCount; i += 1)\n        msDataRef.current[i] = getMeasure(\n          i,\n          useCache && msDataRef.current[i]\n            ? msDataRef.current[i].size\n            : getItemSize(i)\n        );\n    },\n    [getItemSize, getMeasure, itemCount]\n  );\n\n  const getCalcData = useCallback(\n    (scrollOffset: number) => {\n      const { current: msData } = msDataRef;\n      const lastIdx = msData.length - 1;\n      let vStart = 0;\n\n      if (hasDynamicSizeRef.current) {\n        while (\n          vStart < lastIdx &&\n          msData[vStart].start + msData[vStart].size < scrollOffset\n        )\n          vStart += 1;\n      } else {\n        vStart = findNearestBinarySearch(\n          0,\n          lastIdx,\n          scrollOffset,\n          (idx) => msData[idx].start\n        );\n      }\n\n      let vStop = vStart;\n      let currStart = msData[vStop].start;\n\n      while (\n        vStop < lastIdx &&\n        currStart < scrollOffset + outerRectRef.current[sizeKey]\n      ) {\n        currStart += msData[vStop].size;\n        vStop += 1;\n      }\n\n      vStop = vStop === lastIdx ? vStop : vStop - 1;\n      const oStart = Math.max(vStart - overscanCount, 0);\n      const oStop = Math.min(vStop + overscanCount, lastIdx);\n      const innerMargin = msData[oStart].start;\n      const totalSize = Math[oStop < lastIdx ? \"max\" : \"min\"](\n        msData[oStop].end + msData[oStop].size,\n        msData[lastIdx].end\n      );\n\n      return {\n        oStart,\n        oStop,\n        vStart,\n        vStop,\n        innerMargin,\n        innerSize: totalSize - innerMargin,\n      };\n    },\n    [overscanCount, sizeKey]\n  );\n\n  const scrollTo = useCallback(\n    (offset: number, isScrolling = true) => {\n      if (outerRef.current) {\n        userScrollRef.current = false;\n        isScrollingRef.current = isScrolling;\n        outerRef.current[scrollKey] = offset;\n      }\n    },\n    [scrollKey]\n  );\n\n  const scrollToOffset = useCallback<ScrollTo>(\n    (val, cb) => {\n      const { offset, smooth }: ScrollToOptions = isNumber(val)\n        ? { offset: val }\n        : val;\n\n      if (!isNumber(offset)) return;\n\n      if (!smooth) {\n        scrollTo(offset);\n        if (cb) cb();\n\n        return;\n      }\n\n      const { current: prevOffset } = scrollOffsetRef;\n      const start = now();\n\n      const scroll = () => {\n        let { current: duration } = durationRef;\n        duration = isNumber(duration)\n          ? duration\n          : duration(Math.abs(offset - prevOffset));\n        const time = Math.min((now() - start) / duration, 1);\n        const easing = easingFnRef.current(time);\n\n        scrollTo(easing * (offset - prevOffset) + prevOffset);\n\n        if (time < 1) {\n          scrollToRafRef.current = requestAnimationFrame(scroll);\n        } else if (cb) {\n          cb();\n        }\n      };\n\n      scrollToRafRef.current = requestAnimationFrame(scroll);\n    },\n    [durationRef, easingFnRef, scrollTo]\n  );\n\n  const scrollToIndex = useCallback(\n    (\n      val: Parameters<ScrollToItem>[0],\n      cb: Parameters<ScrollToItem>[1],\n      isSync?: boolean\n    ) => {\n      const {\n        index,\n        align = Align.auto,\n        smooth,\n      }: ScrollToItemOptions = isNumber(val) ? { index: val } : val;\n\n      if (!isNumber(index)) return;\n\n      isScrollToItemRef.current = true;\n\n      // For dynamic size, we must measure it for getting the correct scroll position\n      if (hasDynamicSizeRef.current) measureItems();\n\n      const { current: msData } = msDataRef;\n      const ms = msData[Math.max(0, Math.min(index, msData.length - 1))];\n\n      if (!ms) return;\n\n      const { start, end, size } = ms;\n      const totalSize = msData[msData.length - 1].end;\n      const outerSize = outerRectRef.current[sizeKey];\n      let { current: scrollOffset } = scrollOffsetRef;\n\n      if (totalSize <= outerSize) {\n        if (cb) cb();\n        return;\n      }\n\n      if (\n        isSync ||\n        align === Align.start ||\n        (align === Align.auto &&\n          scrollOffset + outerSize > end &&\n          scrollOffset > start)\n      ) {\n        scrollOffset =\n          totalSize - start <= outerSize ? totalSize - outerSize : start;\n      } else if (\n        align === Align.end ||\n        (align === Align.auto &&\n          scrollOffset + outerSize < end &&\n          scrollOffset < start)\n      ) {\n        scrollOffset = start + size <= outerSize ? 0 : start - outerSize + size;\n      } else if (align === Align.center && start + size / 2 > outerSize / 2) {\n        const to = start - outerSize / 2 + size / 2;\n        scrollOffset = totalSize - to <= outerSize ? totalSize - outerSize : to;\n      }\n\n      if (\n        hasDynamicSizeRef.current &&\n        Math.abs(scrollOffset - scrollOffsetRef.current) <= 1\n      ) {\n        if (cb) cb();\n        return;\n      }\n\n      scrollToOffset({ offset: scrollOffset, smooth }, () => {\n        if (!hasDynamicSizeRef.current) {\n          if (cb) cb();\n        } else if (isSync) {\n          requestAnimationFrame(() => scrollToIndex(val, cb, isSync));\n        } else {\n          setTimeout(() => scrollToIndex(val, cb));\n        }\n      });\n    },\n    [measureItems, scrollToOffset, sizeKey]\n  );\n\n  const scrollToItem = useCallback<ScrollToItem>(\n    (val, cb) => scrollToIndex(val, cb),\n    [scrollToIndex]\n  );\n\n  const startItem = useCallback<StartItem>(\n    (idx, cb) => scrollToIndex(idx, cb, true),\n    [scrollToIndex]\n  );\n\n  const [resetIsScrolling, cancelResetIsScrolling] = useDebounce(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    () => handleScroll(scrollOffsetRef.current),\n    150\n  );\n\n  const handleScroll = useCallback(\n    (scrollOffset: number, isScrolling?: boolean, uxScrolling?: boolean) => {\n      if (\n        loadMoreRef.current &&\n        !isMountedRef.current &&\n        !(isItemLoadedRef.current && isItemLoadedRef.current(0))\n      )\n        loadMoreRef.current({\n          startIndex: 0,\n          stopIndex: loadMoreCount - 1,\n          loadIndex: 0,\n          scrollOffset,\n          userScroll: false,\n        });\n\n      if (!itemCount) {\n        setState({ items: [] });\n        return;\n      }\n\n      const calcData = getCalcData(scrollOffset);\n      const { oStart, oStop, vStart, vStop } = calcData;\n      let { innerMargin, innerSize } = calcData;\n      const items: Item[] = [];\n      const stickies = Array.isArray(stickyIndicesRef.current)\n        ? stickyIndicesRef.current\n        : [];\n\n      for (let i = oStart; i <= oStop; i += 1) {\n        const { current: msData } = msDataRef;\n        const { start, size } = msData[i];\n\n        items.push({\n          index: i,\n          start: start - innerMargin,\n          size,\n          width: outerRectRef.current.width,\n          isScrolling: uxScrolling || undefined,\n          isSticky: stickies.includes(i) || undefined,\n          measureRef: (el) => {\n            if (!el) return;\n\n            // eslint-disable-next-line compat/compat\n            new ResizeObserver(([{ target }], ro) => {\n              // NOTE: Use `borderBoxSize` when it's supported by Safari\n              // see: https://caniuse.com/mdn-api_resizeobserverentry_borderboxsize\n              const measuredSize = target.getBoundingClientRect()[sizeKey];\n\n              if (!measuredSize) {\n                ro.disconnect();\n                rosRef.current.delete(target);\n                return;\n              }\n\n              const prevEnd = msData[i - 1]?.end ?? 0;\n\n              if (measuredSize !== size || start !== prevEnd) {\n                // To prevent dynamic size from jumping during backward scrolling\n                if (i < prevItemIdxRef.current && start < scrollOffset)\n                  scrollTo(scrollOffset + measuredSize - size, false);\n\n                msDataRef.current[i] = getMeasure(i, measuredSize);\n                if (!isScrollToItemRef.current)\n                  handleScroll(\n                    scrollOffsetRef.current,\n                    isScrolling,\n                    uxScrolling\n                  );\n\n                hasDynamicSizeRef.current = true;\n              }\n\n              prevItemIdxRef.current = i;\n\n              rosRef.current.get(target)?.disconnect();\n              rosRef.current.set(target, ro);\n            }).observe(el);\n          },\n        });\n      }\n\n      if (stickies.length) {\n        const stickyIdx =\n          stickies[\n            findNearestBinarySearch(\n              0,\n              stickies.length - 1,\n              vStart,\n              (idx) => stickies[idx]\n            )\n          ];\n\n        if (oStart > stickyIdx) {\n          const { size } = msDataRef.current[stickyIdx];\n\n          items.unshift({\n            index: stickyIdx,\n            start: 0,\n            size,\n            width: outerRectRef.current.width,\n            isScrolling: uxScrolling || undefined,\n            isSticky: true,\n            measureRef: /* istanbul ignore next */ () => null,\n          });\n\n          innerMargin -= size;\n          innerSize += size;\n        }\n      }\n\n      setState((prevState) =>\n        shouldUpdate(prevState.items, items, { measureRef: true })\n          ? { items, innerMargin, innerSize }\n          : prevState\n      );\n\n      if (!isScrolling) return;\n\n      const scrollForward = scrollOffset > scrollOffsetRef.current;\n\n      if (onScrollRef.current)\n        onScrollRef.current({\n          overscanStartIndex: oStart,\n          overscanStopIndex: oStop,\n          visibleStartIndex: vStart,\n          visibleStopIndex: vStop,\n          scrollOffset,\n          scrollForward,\n          userScroll: userScrollRef.current,\n        });\n\n      const loadIndex = Math.max(\n        Math.floor((vStop + 1) / loadMoreCount) - (scrollForward ? 0 : 1),\n        0\n      );\n      const startIndex = loadIndex * loadMoreCount;\n\n      if (\n        loadMoreRef.current &&\n        vStop !== prevVStopRef.current &&\n        !(isItemLoadedRef.current && isItemLoadedRef.current(loadIndex))\n      )\n        loadMoreRef.current({\n          startIndex,\n          stopIndex: startIndex + loadMoreCount - 1,\n          loadIndex,\n          scrollOffset,\n          userScroll: userScrollRef.current,\n        });\n\n      if (uxScrolling) resetIsScrolling();\n\n      prevVStopRef.current = vStop;\n    },\n    [\n      stickyIndicesRef,\n      getCalcData,\n      getMeasure,\n      itemCount,\n      loadMoreCount,\n      loadMoreRef,\n      onScrollRef,\n      resetIsScrolling,\n      scrollTo,\n      sizeKey,\n      isItemLoadedRef,\n    ]\n  );\n\n  useResizeEffect<O>(\n    outerRef,\n    (rect) => {\n      const { width, height } = outerRectRef.current;\n      const isSameWidth = width === rect.width;\n      const isSameSize = isSameWidth && height === rect.height;\n      const msDataLen = msDataRef.current.length;\n      const prevTotalSize = msDataRef.current[msDataLen - 1]?.end;\n\n      outerRectRef.current = rect;\n      measureItems(hasDynamicSizeRef.current);\n      handleScroll(scrollOffsetRef.current);\n\n      if (resetScroll && itemCount !== msDataLen)\n        setTimeout(() => scrollTo(0, false));\n\n      if (!isMountedRef.current) {\n        isMountedRef.current = true;\n        return;\n      }\n\n      if (!hasDynamicSizeRef.current && !isSameWidth) {\n        const totalSize = msDataRef.current[msDataRef.current.length - 1]?.end;\n        const ratio = totalSize / prevTotalSize || 1;\n\n        scrollTo(scrollOffsetRef.current * ratio, false);\n      }\n\n      if (!isSameSize && onResizeRef.current) onResizeRef.current(rect);\n    },\n    [itemCount, resetScroll, handleScroll, measureItems, onResizeRef, scrollTo]\n  );\n\n  useIsoLayoutEffect(() => {\n    if (!innerRef.current) return;\n\n    if (isNumber(state.innerMargin))\n      innerRef.current.style[marginKey] = `${state.innerMargin}px`;\n    if (isNumber(state.innerSize))\n      innerRef.current.style[sizeKey] = `${state.innerSize}px`;\n  }, [marginKey, sizeKey, state.innerMargin, state.innerSize]);\n\n  useIsoLayoutEffect(() => {\n    const { current: outer } = outerRef;\n\n    if (!outer) return () => null;\n\n    const scrollHandler = ({ target }: Event) => {\n      const scrollOffset = (target as O)[scrollKey];\n\n      if (scrollOffset === scrollOffsetRef.current) return;\n\n      let { current: uxScrolling } = useIsScrollingRef;\n      uxScrolling =\n        typeof uxScrolling === \"function\"\n          ? uxScrolling(Math.abs(scrollOffset - scrollOffsetRef.current))\n          : uxScrolling;\n\n      handleScroll(scrollOffset, isScrollingRef.current, uxScrolling);\n\n      userScrollRef.current = true;\n      isScrollingRef.current = true;\n      isScrollToItemRef.current = false;\n      scrollOffsetRef.current = scrollOffset;\n    };\n\n    outer.addEventListener(\"scroll\", scrollHandler, { passive: true });\n\n    const ros = rosRef.current;\n\n    return () => {\n      cancelResetIsScrolling();\n      if (scrollToRafRef.current) {\n        cancelAnimationFrame(scrollToRafRef.current);\n        scrollToRafRef.current = undefined;\n      }\n\n      outer.removeEventListener(\"scroll\", scrollHandler);\n\n      ros.forEach((ro) => ro.disconnect());\n      ros.clear();\n    };\n  }, [cancelResetIsScrolling, handleScroll, scrollKey, useIsScrollingRef]);\n\n  return {\n    outerRef,\n    innerRef,\n    items: state.items,\n    scrollTo: scrollToOffset,\n    scrollToItem,\n    startItem,\n  };\n};\n","import { useCallback, useRef } from \"react\";\n\nimport now from \"./now\";\nimport useLatest from \"./useLatest\";\n\ninterface Fn {\n  (): void;\n}\n\nexport default (cb: Fn, delay: number): [Fn, Fn] => {\n  const rafRef = useRef<number>();\n  const cbRef = useLatest(cb);\n\n  const cancel = useCallback(() => {\n    if (rafRef.current) {\n      cancelAnimationFrame(rafRef.current);\n      rafRef.current = undefined;\n    }\n  }, []);\n\n  const tick = useCallback(\n    (start: number) => {\n      if (now() - start >= delay) {\n        cbRef.current();\n      } else {\n        rafRef.current = requestAnimationFrame(() => tick(start));\n      }\n    },\n    [cbRef, delay]\n  );\n\n  const fn = useCallback(() => {\n    cancel();\n    tick(now());\n  }, [cancel, tick]);\n\n  return [fn, cancel];\n};\n","import { Item } from \"../types\";\n\nexport default (\n  prev: Item[],\n  next: Item[],\n  skip: Record<string, boolean>\n): boolean => {\n  if (prev.length !== next.length) return true;\n\n  for (let i = 0; i < prev.length; i += 1)\n    if (\n      Object.keys(prev[i]).some((key) => {\n        const k = key as keyof Item;\n        return !skip[k] && prev[i][k] !== next[i][k];\n      })\n    )\n      return true;\n\n  return false;\n};\n","import { DependencyList, RefObject } from \"react\";\n\nimport { OnResize } from \"../types\";\nimport useIsoLayoutEffect from \"./useIsoLayoutEffect\";\nimport useLatest from \"./useLatest\";\n\nexport default <T extends HTMLElement>(\n  ref: RefObject<T>,\n  cb: OnResize,\n  deps: DependencyList\n): void => {\n  const cbRef = useLatest(cb);\n\n  useIsoLayoutEffect(() => {\n    if (!ref?.current) return () => null;\n\n    // eslint-disable-next-line compat/compat\n    const observer = new ResizeObserver(([{ contentRect }]) => {\n      const { width, height } = contentRect;\n      cbRef.current({ width, height });\n    });\n\n    observer.observe(ref.current);\n\n    return () => observer.disconnect();\n  }, [cbRef, ref, ...deps]);\n};\n"],"names":["Align","findNearestBinarySearch","low","high","input","getVal","mid","val","isNumber","Number","isNaN","now","window","performance","Date","useLatest","ref","useRef","current","useLayoutEffect","useEffect","useVirtual","itemCount","ssrItemCount","itemSize","horizontal","resetScroll","overscanCount","useIsScrolling","stickyIndices","scrollDuration","d","Math","min","max","scrollEasingFunction","t","cos","PI","loadMoreCount","isItemLoaded","loadMore","onScroll","onResize","useState","getInitState","items","i","len","push","index","start","width","size","measureRef","state","setState","isMountedRef","isScrollingRef","isScrollToItemRef","hasDynamicSizeRef","rosRef","Map","scrollOffsetRef","prevItemIdxRef","prevVStopRef","outerRef","innerRef","outerRectRef","height","msDataRef","userScrollRef","scrollToRafRef","stickyIndicesRef","durationRef","easingFnRef","isItemLoadedRef","loadMoreRef","itemSizeRef","useIsScrollingRef","onScrollRef","onResizeRef","sizeKey","marginKey","scrollKey","getItemSize","useCallback","idx","getMeasure","_msDataRef$current","end","measureItems","useCache","length","getCalcData","scrollOffset","msData","lastIdx","vStart","vStop","currStart","innerMargin","oStart","oStop","innerSize","scrollTo","offset","isScrolling","scrollToOffset","cb","smooth","prevOffset","requestAnimationFrame","scroll","duration","abs","easing","time","scrollToIndex","isSync","align","auto","ms","outerSize","totalSize","center","to","setTimeout","useDebounce","delay","rafRef","cbRef","cancel","cancelAnimationFrame","undefined","tick","handleScroll","resetIsScrolling","cancelResetIsScrolling","uxScrolling","startIndex","stopIndex","loadIndex","userScroll","calcData","stickies","Array","isArray","isSticky","includes","el","observe","ResizeObserver","ro","measuredSize","target","getBoundingClientRect","prevEnd","_msData","get","disconnect","set","stickyIdx","unshift","prevState","shouldUpdate","prev","next","skip","Object","keys","some","key","scrollForward","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","floor","useResizeEffect","deps","observer","contentRect","rect","isSameWidth","msDataLen","prevTotalSize","_msDataRef$current2","_msDataRef$current3","isSameSize","style","outer","scrollHandler","addEventListener","passive","ros","removeEventListener","forEach","clear","scrollToItem","startItem"],"mappings":"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"}