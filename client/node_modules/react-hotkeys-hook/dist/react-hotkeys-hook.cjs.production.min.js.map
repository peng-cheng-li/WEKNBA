{"version":3,"file":"react-hotkeys-hook.cjs.production.min.js","sources":["../src/parseHotkeys.ts","../src/isHotkeyPressed.ts","../src/validators.ts","../src/BoundHotkeysProxyProvider.tsx","../src/deepEqual.ts","../src/HotkeysProvider.tsx","../src/useHotkeys.ts","../src/useDeepEqualMemo.ts","../src/useRecordHotkeys.ts"],"sourcesContent":["import { Hotkey, KeyboardModifiers, Keys } from './types'\n\nconst reservedModifierKeywords = ['shift', 'alt', 'meta', 'mod']\n\nconst mappedKeys: Record<string, string> = {\n  esc: 'escape',\n  return: 'enter',\n  '.': 'period',\n  ',': 'comma',\n  '-': 'slash',\n  ' ': 'space',\n  '#': 'backslash',\n  '+': 'bracketright',\n  'ShiftLeft': 'shift',\n  'ShiftRight': 'shift',\n  'AltLeft': 'alt',\n  'AltRight': 'alt',\n  'MetaLeft': 'meta',\n  'MetaRight': 'meta',\n  'ControlLeft': 'ctrl',\n  'ControlRight': 'ctrl',\n}\n\nexport function mapKey(key: string): string {\n  return (mappedKeys[key] || key)\n    .trim()\n    .toLowerCase()\n    .replace('key', '')\n    .replace('digit', '')\n    .replace('numpad', '')\n    .replace('arrow', '')\n}\n\nexport function isHotkeyModifier(key: string) {\n  return reservedModifierKeywords.includes(key)\n}\n\nexport function parseKeysHookInput(keys: Keys, splitKey: string = ','): string[] {\n  if (typeof keys === 'string') {\n    return keys.split(splitKey)\n  }\n\n  return keys\n}\n\nexport function parseHotkey(hotkey: string, combinationKey: string = '+'): Hotkey {\n  const keys = hotkey\n    .toLocaleLowerCase()\n    .split(combinationKey)\n    .map(k => mapKey(k))\n\n  const modifiers: KeyboardModifiers = {\n    alt: keys.includes('alt'),\n    shift: keys.includes('shift'),\n    meta: keys.includes('meta'),\n    mod: keys.includes('mod'),\n  }\n\n  const singleCharKeys = keys.filter((k) => !reservedModifierKeywords.includes(k))\n\n  return {\n    ...modifiers,\n    keys: singleCharKeys,\n  }\n}\n","import { isHotkeyModifier, mapKey } from './parseHotkeys'\n\nconst currentlyPressedKeys: Set<string> = new Set<string>()\n\nexport function isHotkeyPressed(key: string | string[], splitKey: string = ','): boolean {\n  const hotkeyArray = Array.isArray(key) ? key : key.split(splitKey)\n\n  return hotkeyArray.every((hotkey) => currentlyPressedKeys.has(hotkey.trim().toLowerCase()))\n}\n\nexport function pushToCurrentlyPressedKeys(key: string | string[]): void {\n  const hotkeyArray = Array.isArray(key) ? key : [key]\n\n  /*\n  Due to a weird behavior on macOS we need to clear the set if the user pressed down the meta key and presses another key.\n  https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser\n  Otherwise the set will hold all ever pressed keys while the meta key is down which leads to wrong results.\n   */\n  if (currentlyPressedKeys.has('meta')) {\n    currentlyPressedKeys.forEach(key => !isHotkeyModifier(key) && currentlyPressedKeys.delete(key.toLowerCase()))\n  }\n\n  hotkeyArray.forEach(hotkey => currentlyPressedKeys.add(hotkey.toLowerCase()))\n}\n\nexport function removeFromCurrentlyPressedKeys(key: string | string[]): void {\n  const hotkeyArray = Array.isArray(key) ? key : [key]\n\n  /*\n  Due to a weird behavior on macOS we need to clear the set if the user pressed down the meta key and presses another key.\n  https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser\n  Otherwise the set will hold all ever pressed keys while the meta key is down which leads to wrong results.\n   */\n  if (key === 'meta') {\n    currentlyPressedKeys.clear()\n  } else {\n    hotkeyArray.forEach(hotkey => currentlyPressedKeys.delete(hotkey.toLowerCase()))\n  }\n}\n\n(() => {\n  if (typeof document !== 'undefined') {\n    document.addEventListener('keydown', e => {\n      if (e.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      pushToCurrentlyPressedKeys([mapKey(e.key), mapKey(e.code)])\n    })\n\n    document.addEventListener('keyup', e => {\n      if (e.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      removeFromCurrentlyPressedKeys([mapKey(e.key), mapKey(e.code)])\n    })\n  }\n\n  if (typeof window !== 'undefined') {\n    window.addEventListener('blur', () => {\n      currentlyPressedKeys.clear()\n    })\n  }\n})()\n","import { FormTags, Hotkey, Scopes, Trigger } from './types'\nimport { isHotkeyPressed } from './isHotkeyPressed'\nimport { mapKey } from './parseHotkeys'\n\nexport function maybePreventDefault(e: KeyboardEvent, hotkey: Hotkey, preventDefault?: Trigger): void {\n  if ((typeof preventDefault === 'function' && preventDefault(e, hotkey)) || preventDefault === true) {\n    e.preventDefault()\n  }\n}\n\nexport function isHotkeyEnabled(e: KeyboardEvent, hotkey: Hotkey, enabled?: Trigger): boolean {\n  if (typeof enabled === 'function') {\n    return enabled(e, hotkey)\n  }\n\n  return enabled === true || enabled === undefined\n}\n\nexport function isKeyboardEventTriggeredByInput(ev: KeyboardEvent): boolean {\n  return isHotkeyEnabledOnTag(ev, ['input', 'textarea', 'select'])\n}\n\nexport function isHotkeyEnabledOnTag({ target }: KeyboardEvent, enabledOnTags: FormTags[] | boolean = false): boolean {\n  const targetTagName = target && (target as HTMLElement).tagName\n\n  if (enabledOnTags instanceof Array) {\n    return Boolean(targetTagName && enabledOnTags && enabledOnTags.some(tag => tag.toLowerCase() === targetTagName.toLowerCase()))\n  }\n\n  return Boolean(targetTagName && enabledOnTags && enabledOnTags === true)\n}\n\nexport function isScopeActive(activeScopes: string[], scopes?: Scopes): boolean {\n  if (activeScopes.length === 0 && scopes) {\n    console.warn(\n      'A hotkey has the \"scopes\" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>',\n    )\n\n    return true\n  }\n\n  if (!scopes) {\n    return true\n  }\n\n  return activeScopes.some(scope => scopes.includes(scope)) || activeScopes.includes('*')\n}\n\nexport const isHotkeyMatchingKeyboardEvent = (e: KeyboardEvent, hotkey: Hotkey, ignoreModifiers: boolean = false): boolean => {\n  const { alt, meta, mod, shift, keys } = hotkey\n  const { key: pressedKeyUppercase, code } = e\n\n  const altKey = isHotkeyPressed('alt')\n  const shiftKey = isHotkeyPressed('shift')\n  const metaKey = isHotkeyPressed('meta')\n  const ctrlKey = isHotkeyPressed('ctrl')\n\n  const keyCode = mapKey(code)\n  const pressedKey = pressedKeyUppercase.toLowerCase()\n\n  if (!ignoreModifiers) {\n    if (altKey !== alt && pressedKey !== 'alt') {\n      return false\n    }\n\n    if (shiftKey !== shift && pressedKey !== 'shift') {\n      return false\n    }\n\n    // Mod is a special key name that is checking for meta on macOS and ctrl on other platforms\n    if (mod) {\n      if (!metaKey && !ctrlKey) {\n        return false\n      }\n    } else {\n      if (metaKey !== meta && ctrlKey !== meta && keyCode !== 'meta' && keyCode !== 'ctrl') {\n        return false\n      }\n    }\n  }\n\n  // All modifiers are correct, now check the key\n  // If the key is set, we check for the key\n  if (keys && keys.length === 1 && (keys.includes(pressedKey) || keys.includes(keyCode))) {\n    return true\n  } else if (keys) {\n    // Check if all keys are present in pressedDownKeys set\n    return isHotkeyPressed(keys)\n  } else if (!keys) {\n    // If the key is not set, we only listen for modifiers, that check went alright, so we return true\n    return true\n  }\n\n  // There is nothing that matches.\n  return false\n}\n","import { createContext, ReactNode, useContext } from 'react'\nimport { Hotkey } from './types'\n\ntype BoundHotkeysProxyProviderType = {\n  addHotkey: (hotkey: Hotkey) => void,\n  removeHotkey: (hotkey: Hotkey) => void,\n}\n\nconst BoundHotkeysProxyProvider = createContext<BoundHotkeysProxyProviderType | undefined>(undefined)\n\nexport const useBoundHotkeysProxy = () => {\n  return useContext(BoundHotkeysProxyProvider)\n}\n\ninterface Props {\n  children: ReactNode\n  addHotkey: (hotkey: Hotkey) => void\n  removeHotkey: (hotkey: Hotkey) => void\n}\n\nexport default function BoundHotkeysProxyProviderProvider({ addHotkey, removeHotkey, children }: Props) {\n  return <BoundHotkeysProxyProvider.Provider value={{addHotkey, removeHotkey}}>{children}</BoundHotkeysProxyProvider.Provider>\n}\n","export default function deepEqual(x: any, y: any): boolean {\n  //@ts-ignore\n  return (x && y && typeof x === 'object' && typeof y === 'object')\n    //@ts-ignore\n    ? (Object.keys(x).length === Object.keys(y).length) && Object.keys(x).reduce(function(isEqual, key) {\n      return isEqual && deepEqual(x[key], y[key])\n    }, true)\n    : (x === y)\n}\n","import { Hotkey } from './types'\nimport { createContext, ReactNode, useState, useContext, useCallback } from 'react'\nimport BoundHotkeysProxyProviderProvider from './BoundHotkeysProxyProvider'\nimport deepEqual from './deepEqual'\n\nexport type HotkeysContextType = {\n  hotkeys: ReadonlyArray<Hotkey>\n  enabledScopes: string[]\n  toggleScope: (scope: string) => void\n  enableScope: (scope: string) => void\n  disableScope: (scope: string) => void\n}\n\n// The context is only needed for special features like global scoping, so we use a graceful default fallback\nconst HotkeysContext = createContext<HotkeysContextType>({\n  hotkeys: [],\n  enabledScopes: [], // This array has to be empty instead of containing '*' as default, to check if the provider is set or not\n  toggleScope: () => {},\n  enableScope: () => {},\n  disableScope: () => {},\n})\n\nexport const useHotkeysContext = () => {\n  return useContext(HotkeysContext)\n}\n\ninterface Props {\n  initiallyActiveScopes?: string[]\n  children: ReactNode\n}\n\nexport const HotkeysProvider = ({initiallyActiveScopes = ['*'], children}: Props) => {\n  const [internalActiveScopes, setInternalActiveScopes] = useState(initiallyActiveScopes?.length > 0 ? initiallyActiveScopes : ['*'])\n  const [boundHotkeys, setBoundHotkeys] = useState<Hotkey[]>([]);\n\n  const enableScope = useCallback((scope: string) => {\n    setInternalActiveScopes((prev) => {\n      if (prev.includes('*')) {\n        return [scope]\n      }\n\n      return Array.from(new Set([...prev, scope]))\n    })\n  }, [])\n\n  const disableScope = useCallback((scope: string) => {\n    setInternalActiveScopes((prev) => {\n      if (prev.filter(s => s !== scope).length === 0) {\n        return ['*']\n      } else {\n        return prev.filter(s => s !== scope)\n      }\n    })\n  }, [])\n\n  const toggleScope = useCallback((scope: string) => {\n    setInternalActiveScopes((prev) => {\n      if (prev.includes(scope)) {\n        if (prev.filter(s => s !== scope).length === 0) {\n          return ['*']\n        } else {\n          return prev.filter(s => s !== scope)\n        }\n      } else {\n        if (prev.includes('*')) {\n          return [scope]\n        }\n\n        return Array.from(new Set([...prev, scope]))\n      }\n    })\n  }, [])\n\n  const addBoundHotkey = useCallback((hotkey: Hotkey) => {\n    setBoundHotkeys((prev) => [...prev, hotkey])\n  }, [])\n\n  const removeBoundHotkey = useCallback((hotkey: Hotkey) => {\n    setBoundHotkeys((prev) => prev.filter(h => !deepEqual(h, hotkey)))\n  }, [])\n\n  return (\n    <HotkeysContext.Provider value={{enabledScopes: internalActiveScopes, hotkeys: boundHotkeys, enableScope, disableScope, toggleScope}}>\n      <BoundHotkeysProxyProviderProvider addHotkey={addBoundHotkey} removeHotkey={removeBoundHotkey}>\n        {children}\n      </BoundHotkeysProxyProviderProvider>\n    </HotkeysContext.Provider>\n  )\n}\n","import { HotkeyCallback, Keys, Options, OptionsOrDependencyArray, RefType } from './types'\nimport { DependencyList, useCallback, useEffect, useLayoutEffect, useRef } from 'react'\nimport { mapKey, parseHotkey, parseKeysHookInput } from './parseHotkeys'\nimport {\n  isHotkeyEnabled,\n  isHotkeyEnabledOnTag,\n  isHotkeyMatchingKeyboardEvent,\n  isKeyboardEventTriggeredByInput,\n  isScopeActive,\n  maybePreventDefault,\n} from './validators'\nimport { useHotkeysContext } from './HotkeysProvider'\nimport { useBoundHotkeysProxy } from './BoundHotkeysProxyProvider'\nimport useDeepEqualMemo from './useDeepEqualMemo'\nimport { pushToCurrentlyPressedKeys, removeFromCurrentlyPressedKeys } from './isHotkeyPressed'\n\nconst stopPropagation = (e: KeyboardEvent): void => {\n  e.stopPropagation()\n  e.preventDefault()\n  e.stopImmediatePropagation()\n}\n\nconst useSafeLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\nexport default function useHotkeys<T extends HTMLElement>(\n  keys: Keys,\n  callback: HotkeyCallback,\n  options?: OptionsOrDependencyArray,\n  dependencies?: OptionsOrDependencyArray,\n) {\n  const ref = useRef<RefType<T>>(null)\n  const hasTriggeredRef = useRef(false)\n\n  const _options: Options | undefined = !(options instanceof Array) ? (options as Options) : !(dependencies instanceof Array) ? (dependencies as Options) : undefined\n  const _deps: DependencyList = options instanceof Array ? options : dependencies instanceof Array ? dependencies : []\n\n  const cb = useCallback(callback, [..._deps])\n  const memoisedOptions = useDeepEqualMemo(_options)\n\n  const { enabledScopes } = useHotkeysContext()\n  const proxy = useBoundHotkeysProxy()\n\n  useSafeLayoutEffect(() => {\n    if (memoisedOptions?.enabled === false || !isScopeActive(enabledScopes, memoisedOptions?.scopes)) {\n      return\n    }\n\n    const listener = (e: KeyboardEvent, isKeyUp: boolean = false) => {\n      if (isKeyboardEventTriggeredByInput(e) && !isHotkeyEnabledOnTag(e, memoisedOptions?.enableOnFormTags)) {\n        return\n      }\n\n      // TODO: SINCE THE EVENT IS NOW ATTACHED TO THE REF, THE ACTIVE ELEMENT CAN NEVER BE INSIDE THE REF. THE HOTKEY ONLY TRIGGERS IF THE\n      // REF IS THE ACTIVE ELEMENT. THIS IS A PROBLEM SINCE FOCUSED SUB COMPONENTS WON'T TRIGGER THE HOTKEY.\n      if (ref.current !== null && document.activeElement !== ref.current && !ref.current.contains(document.activeElement)) {\n        stopPropagation(e)\n\n        return\n      }\n\n      if (((e.target as HTMLElement)?.isContentEditable && !memoisedOptions?.enableOnContentEditable)) {\n        return\n      }\n\n      parseKeysHookInput(keys, memoisedOptions?.splitKey).forEach((key) => {\n        const hotkey = parseHotkey(key, memoisedOptions?.combinationKey)\n\n        if ((isHotkeyMatchingKeyboardEvent(e, hotkey, memoisedOptions?.ignoreModifiers) || hotkey.keys?.includes('*')) && !hasTriggeredRef.current) {\n          maybePreventDefault(e, hotkey, memoisedOptions?.preventDefault)\n\n          if (!isHotkeyEnabled(e, hotkey, memoisedOptions?.enabled)) {\n            stopPropagation(e)\n\n            return\n          }\n\n          // Execute the user callback for that hotkey\n          cb(e, hotkey)\n\n          if (!isKeyUp) {\n            hasTriggeredRef.current = true\n          }\n        }\n      })\n    }\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      pushToCurrentlyPressedKeys(mapKey(event.code))\n\n      if ((memoisedOptions?.keydown === undefined && memoisedOptions?.keyup !== true) || memoisedOptions?.keydown) {\n        listener(event)\n      }\n    }\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (event.key === undefined) {\n        // Synthetic event (e.g., Chrome autofill).  Ignore.\n        return\n      }\n\n      removeFromCurrentlyPressedKeys(mapKey(event.code))\n\n      hasTriggeredRef.current = false\n\n      if (memoisedOptions?.keyup) {\n        listener(event, true)\n      }\n    }\n\n    // @ts-ignore\n    (ref.current || _options?.document || document).addEventListener('keyup', handleKeyUp);\n    // @ts-ignore\n    (ref.current || _options?.document || document).addEventListener('keydown', handleKeyDown)\n\n    if (proxy) {\n      parseKeysHookInput(keys, memoisedOptions?.splitKey).forEach((key) => proxy.addHotkey(parseHotkey(key, memoisedOptions?.combinationKey)))\n    }\n\n    return () => {\n      // @ts-ignore\n      (ref.current || _options?.document || document).removeEventListener('keyup', handleKeyUp);\n      // @ts-ignore\n      (ref.current || _options?.document || document).removeEventListener('keydown', handleKeyDown)\n\n      if (proxy) {\n        parseKeysHookInput(keys, memoisedOptions?.splitKey).forEach((key) => proxy.removeHotkey(parseHotkey(key, memoisedOptions?.combinationKey)))\n      }\n    }\n  }, [keys, cb, memoisedOptions, enabledScopes])\n\n  return ref\n}\n","import { useRef } from 'react'\nimport deepEqual from './deepEqual'\n\nexport default function useDeepEqualMemo<T>(value: T) {\n  const ref = useRef<T | undefined>(undefined)\n\n  if (!deepEqual(ref.current, value)) {\n    ref.current = value\n  }\n\n  return ref.current\n}\n","import { useCallback, useState } from 'react'\nimport { mapKey } from './parseHotkeys'\n\nexport default function useRecordHotkeys() {\n  const [keys, setKeys] = useState(new Set<string>())\n  const [isRecording, setIsRecording] = useState(false);\n\n  const handler = useCallback((event: KeyboardEvent) => {\n    if (event.key === undefined) {\n      // Synthetic event (e.g., Chrome autofill).  Ignore.\n      return\n    }\n\n    event.preventDefault()\n    event.stopPropagation()\n\n    setKeys(prev => {\n      const newKeys = new Set(prev)\n\n      newKeys.add(mapKey(event.code))\n\n      return newKeys\n    })\n  }, [])\n\n  const stop = useCallback(() => {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener('keydown', handler)\n\n      setIsRecording(false)\n    }\n  }, [handler])\n\n  const start = useCallback(() => {\n    setKeys(new Set<string>())\n\n    if (typeof document !== 'undefined') {\n      stop()\n\n      document.addEventListener('keydown', handler)\n\n      setIsRecording(true)\n    }\n  }, [handler, stop])\n\n  return [keys, { start, stop, isRecording }] as const\n}\n"],"names":["reservedModifierKeywords","mappedKeys","esc","return",".",",","-"," ","#","+","ShiftLeft","ShiftRight","AltLeft","AltRight","MetaLeft","MetaRight","ControlLeft","ControlRight","mapKey","key","trim","toLowerCase","replace","parseKeysHookInput","keys","splitKey","split","parseHotkey","hotkey","combinationKey","toLocaleLowerCase","map","k","alt","includes","shift","meta","mod","filter","currentlyPressedKeys","Set","isHotkeyPressed","Array","isArray","every","has","pushToCurrentlyPressedKeys","hotkeyArray","forEach","isHotkeyModifier","add","removeFromCurrentlyPressedKeys","clear","isHotkeyEnabledOnTag","enabledOnTags","target","targetTagName","tagName","Boolean","some","tag","document","addEventListener","e","undefined","code","window","BoundHotkeysProxyProvider","createContext","BoundHotkeysProxyProviderProvider","_jsx","Provider","value","addHotkey","removeHotkey","children","deepEqual","x","y","Object","length","reduce","isEqual","HotkeysContext","hotkeys","enabledScopes","toggleScope","enableScope","disableScope","useHotkeysContext","useContext","stopPropagation","preventDefault","stopImmediatePropagation","useSafeLayoutEffect","useLayoutEffect","useEffect","initiallyActiveScopes","useState","internalActiveScopes","setInternalActiveScopes","boundHotkeys","setBoundHotkeys","useCallback","scope","prev","from","s","addBoundHotkey","removeBoundHotkey","h","callback","options","dependencies","ref","useRef","hasTriggeredRef","_options","cb","memoisedOptions","current","useDeepEqualMemo","proxy","enabled","scopes","activeScopes","console","warn","listener","isKeyUp","enableOnFormTags","activeElement","contains","_e$target","isContentEditable","enableOnContentEditable","ignoreModifiers","pressedKeyUppercase","altKey","shiftKey","metaKey","ctrlKey","keyCode","pressedKey","isHotkeyMatchingKeyboardEvent","_hotkey$keys","maybePreventDefault","isHotkeyEnabled","handleKeyDown","event","keydown","keyup","handleKeyUp","removeEventListener","setKeys","isRecording","setIsRecording","handler","newKeys","stop","start"],"mappings":"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"}